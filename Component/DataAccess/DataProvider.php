<?php

namespace CTLib\Component\DataAccess;

use CTLib\Util\Arr;

/**
 * Facilitates retrieving and processing data
 * results into structured data.
 *
 * @author David McLean <dmclean@celltrak.com>
 */
class DataProvider
{
    /**
     * @var array
     */
    protected $fields;


    /**
     * DataProvider constructor.
     */
    public function __construct()
    {
        $this->fields        = [];
        $this->onRecordAdded = null;
    }

    /**
     * @param $method
     *
     * @throws \Exception
     */
    public function setOnRecordAdded($method)
    {
        $this->onRecordAdded = $method;
    }

    /**
     * Method to facilitate field management between
     * the data retrieval and the final output result.
     *
     * @param $field string|callable
     * $param $alias string
     *
     * @return DataProvider
     *
     * @throws \Exception
     */
    public function addField($field, $alias=null)
    {
        if (is_callable($field) && !$alias) {
            throw new \InvalidArgumentException('alias is required for callable');
        }

        if (!$alias) {
            $alias = $field;
        }

        $this->fields[$alias] = $field;

        return $this;
    }

    /**
     * Get transformed data retrieved from data source.
     * Output will be whatever is generated by the
     * data output class.
     *
     * @param DataAccessInterface $dataAccess
     * @param DataOutputInterface $output
     *
     * @return mixed
     */
    public function getResult(
        DataAccessInterface $dataAccess,
        DataOutputInterface $output
    ) {
        $dataSourceFields = $dataAccess->getFields();
        // Merge fields from data access with data provider's
        // additional fields (aliases) to hand over to output.
        $allFields = array_merge(
            $dataSourceFields,
            array_keys($this->fields)
        );

        $output->start($allFields);

        $data = $dataAccess->getData();

        foreach ($data as $rawRecord) {
            $record = [];

            foreach ($this->fields as $alias => $field) {
                if (is_string($field)) {
                    // Retrieve from $rawRecord using array path
                    $value = Arr::findByKeyChain($rawRecord, $field);
                } else {
                    // Hand off to callback to get value
                    $value = call_user_func($field, $rawRecord);
                }
                $record[$alias] = $value;
            }
            $output->addRecord($record);

            if ($this->onRecordAdded) {
                call_user_func($this->onRecordAdded, $record, $output);
            }
        }

        return $output->end();
    }
}
